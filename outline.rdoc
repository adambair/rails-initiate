= Rails Initiate

Past instructors include Adam Bair and Joe Grossberg

=== Description
This course is designed to introduce you to the basics of Ruby on Rails.

=== Installfest

* Who needs help getting Ruby and Rails up and running on their machines?

=== Windows

* Download and run the Ruby installer

    http://rubyinstaller.org

* Make sure that c:\Ruby\bin is in your path
* Verify that Ruby is installed (via command line)

    Start -> Run -> cmd

    ruby -v  #=> should give you a version number
    irb      #=> should load Interactive Ruby
    gem -v   #=> should give you a version number

* Install rails via RubyGems (which comes with the Ruby Installer)

    gem install rails

* Verify that Rails is installed correctly

    rails -v #=> should give you a version number

* Download the sqlite3 command line binary

    http://www.sqlite.org/sqlite-3_6_19.zip

* Download the sqlite3 dlls
  
    http://www.sqlite.org/sqlitedll-3_6_19.zip

* Unzip both files    
* Copy sqlite3.def and sqlite3.dll to c:\windows\system32
* Copy sqlite3.exe to c:\windows\system32

* Install you preferred text editor
  - We recommend E for this class (basically Textmate for windows)

    http://www.e-texteditor.com/

  - You may also want to consider using Vim.

    http://www.vim.org/download.php

=== OSX
You can use the version of Ruby that is included with OSX but I find that it makes life easier in the long run to reinstall Ruby through Macports. You can easily update Ruby and anything that you install from Macports will be aware of your updated version.

* Make sure you install the Developer Tools which includes XCode and the GCC compiler.
* You can install this from the 2nd disk that comes with OSX called 'Developer Tools'
* If you don't have this disk you can download XCode from Apple (about 700MB)
  
  http://developer.apple.com/mac

* Download and install Macports

    http://www.macports.org/install.php

* Verify that Macports is installed correctly

    port #=> then type quit to exit

* Install Ruby via Macports

    sudo port install ruby

* Make sure that you update your path so that /usr/local/bin is first
  - This will ensure that binaries installed by Macports are picked up before the OSX version.

* Verify that Ruby is installed correctly

    ruby -v  #=> should give you a version number
    irb      #=> should load Interactive Ruby

* Install sqlite3 from Macports

    sudo port install sqlite3

* Install the ruby sqlite3 library via RubyGems

    sudo gem install sqlite3-ruby

* Verify that sqlite3 is installed correctly

    sqlite3 --version #=> should display a version number

* Install Ruby on Rails via RubyGems
  
    sudo gem install rails

* Verify that Rails is installed correctly

    rails -v #=> should give you a version number

* Install you preferred text editor
  - We recommend Textmate for this class.

    http://macromates.com/

  - You may also want to consider using Vim.

    http://www.vim.org/download.php

=== Linux

* Use whatever package manager your comfortable with (yum, apt, portage, etc)
* Install ruby, rubygems, sqlite3, and rails
* The instructions should be about the same as OSX
* Just substitute Macports with the package manager of your choice
* Install your preferred editor

=== Creating a New Rails Application
* The 'rails some_name' will create a new directory called 'some_name'
* It will then build out the basic framework in which you can build your application

    rails name_of_application

=== Anatomy of a Rails applicatoin

    app     #=> models, views, controllers, helpers, app logic
    config  #=> database, environment configuration, routes
    db      #=> migrations, schema.rb
    doc     #=> a place for your app's documentation
    lib     #=> library files, rake tasks, code that doesn't fit in the app/* folders
    log     #=> log files for all of your environments (prod, dev, test)
    public  #=> accessable to everyone, images, javascript, stylesheets, static pages
    script  #=> console, server, generators
    spec    #=> rspec tests/specifications and configuration
    test    #=> built in test suite Test::Unit
    tmp     #=> sessions, cache, etc
    vendor  #=> 3rd party code, plugins, gems, vendored rails

=== Basic Anatomy of a Rails Request


                                    -> Model
    Browser -> Routes -> Controller -> View   -> Browser
                                    -> Helper


=== Starting a Rails application
    
    ruby script/server  #=> start app in dev mode at http://localhost:3000
    ruby script/server -p 4000 #=> starts the app at http://localhost:4000
    ruby script/server -e production #=> start the application in production mode

=== Lab 01: Create a Rails Application [ 01_create_a_rails_application.rb ]
* Use the 'rails' command to create a new application callled 'blog'
* Test your application by running 'ruby script/server' in the blog folder
* View your application in a web browser
* Explore the directory structure of your newly created application

=== Generators
Generators will allow you to rapidly add baseline functionality to a Rails application

* There are built in generators that come with rails
* There are also custom generators provided by 3rd party libraries
* Once you're comfortable with Ruby and Rails you can evne create your own

    ruby script/generate #=> will list all available generators

=== Creating a Scaffold
A Scaffold will create all views, models, controllers, routes, and migrations for a resource

    ruby script/generate scaffold #=> will explain what the generator does

    ruby script/generate scaffold Post title:string body:text
      # the title/body arguments are what populate your migration

=== Running a migration
After you create a scaffold you'll need to run the migration to create the proper table and fields within your database.

    rake db:migrate   #=> run all new migrations on the development database

=== Reversing a migration

    rake db:rollback  #=> undo the last migration

=== NEVER MODIFY OLD MIGRATIONS
* This will caus headaches for other developers and for deployments
* 'rake db:migrate' will only run the newest migrations
* Old migrations are never run again unless you go all the way back down
* Think of migrations as 'run once' operations
* If you need to change something in the database, make a new migration
* Modifying old migrations will bite you sooner or later

=== Removing a Scaffold
If you have run migrations from a scaffold, you need to rollback your migration before deleting the scaffold (which will also delete the migration)

    rake db:rollback
    ruby script/destroy scaffold Post

=== Lab 02: Create a Post Resource [ 02_create_a_post_resource.rb ]
* Use the scaffold generator to create a Post resource
* The Post should have a title, body, and author fields
* Use rake to migrate your database
* Start your application and explore the freshly minted scaffold

=== Rake
rake (Ruby make) is a tool to run 'tasks' such as migrations, tests, etc

* Rake tasks are simply specialized Ruby files
* All the code within a task is Ruby

* Rake tasks are usually loosly related utility tasks that are not required during the normal run of your application. Examples:
  - Data imports
  - Data conversions
  - Rotating logs
  - Running tests
  - Running migrations
  - Running code metrics

* You can list all rake tasks associated with an application by using '-T'

    rake -T       #=> list all tasks in an application
    rake -T db    #=> list all tasks with 'db' in the name
    rake -t test  #=> list all tasks with 'test' in the name

=== Console
* The Rails Console is like irb but within the context of your Rails application
* You can access any part of your application through the console
* Execute arbitrary ruby code on the fly just like in irb

    ruby script/console
    
    Post              #=> List all of the columns in the posts table

    Post.all          #=> Finds all posts
    Post.last         #=> Finds last post
    Post.first        #=> Finds first post

    post = Post.new(:title => 'happy', :body => 'smiles')
    post.save         #=> Saves the new object to the database

    Post.create(:title => 'happy', :body => 'smiles')
                      #=> Will save the object directly to the database

    Post.find_by_title('happy')
                      #=> Finds first post with the title happy

    Post.find_all_by_title('happy')
                      #=> Finds all posts with the title happy

    Post.destroy_all  #=> Deletes all posts from the database

=== Routes
* Routes live in config/routes.rb
* This is where you specify what actions are available for your application

    map.resources :posts
    # generate all routes for the posts_controller
    # localhost:3000/posts

    map.root => :controller_name, :action => :action_name
    # change the default route for your application to point at the specified location
    # make sure to delete public/index.html for the root route to be functional

=== Display all available routes

    rake routes
    # display all routes available to your application

=== Lab 03: Remove Default Rails Page [ 03_remove_default_rails_page.rb ]
* Remove the default Rails landing page (Welcome to Rails)
* Create a route that will display all of your Posts at localhost:3000/

=== Models
Models interact with the database and contain the logic for your application

* Models are Ruby classes that descend from ActiveRecord::Base

* ActiveRecord is an ORM that provides all database functionality
    
* Question: What is an ORM?

    ORM stands for Object Relational Mapper
    It maps SQL statements to code and objects
    It essentially translates code into SQL statments

* This is where the business logic should live

* All of the data associations and validations live here
  - validation examples
      http://ar.rubyonrails.org/classes/ActiveRecord/Validations/ClassMethods.html
  - association examples
      http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html
  - customize validation messages using
      validates_presence_of :name, :message => 'custom message'

=== Lab 04: Create a Comment Resource [ 04_create_a_comment_resource.rb ]
* Use scaffolding to create a Comment resource with author and body fields
* Extra Credit: Don't use scaffolding (generators are allowed)
* Verify your new resource in a browser

=== ActiveRecord Relationships: has_many / belongs_to
* Two halves of a single relationship
* The belongs_to side of the association is where the foriegn key is located

    class Author
      has_many :books
    end

    class Book
      belongs_to :author
    end

* The argument for belongs_to is singular while has_many's is plural
* This relationship hinges upon a field in the book table 'author_id'
* ActiveRecord assumes that this field exists
* The x_id assumes that x is the lowercase classname of the relationship ex:

    class Student
      has_many :books
    end

    class Book
      belongs_to :student
    end

    # the books table would need to have a student_id field

=== Lab 05: Post Comment Association [ 05_post_comment_association.rb ]
* Create a migration that adds a 'post_id' field to the comments table
* Create a has_many relationship between the Post and Comment models
* Verify the relationship through the Rails console
 
=== Controllers

* Handle all of the requests to your application
* Broker data between the Model and the View layers of MVC
* Methods within controllers that are available for requests are called 'actions'
* Provide data to your views using instance variables
  - The @ sign denotes an instance variable: @post or @posts for example
  - Keep the number of instance variables to a minimum per request for clarity
* Protect methods that are not meant to be hit directly from the web with private or protected
* Session and authentication management happens here in the Controller layer of MVC
* Anything request driven lives here
* Keep controllers small by keeping business logic in your models

=== Default actions for RESTFUL Controllers
* By default you will have 7 actions available

    # GET /comments
    def index
    end

    # GET /comments/1
    def show
    end

    # GET /comments/new
    def new
    end

    # GET /comments/1/edit
    def edit
    end

    # POST /comments
    def create
    end

    # PUT /comments/1
    def update
    end

    # DELETE /comments/1
    def destroy
    end

* These 7 actions allow for all of the basic CRUD operations
* These actions also map to HTTP verbs to create a RESTful interface

* Question: What are CRUD operations?

    CRUD stands for: 'create', 'read', 'update', 'destroy'
    CRUD maps to the standard HTTP verbs

* Question: What are HTTP verbs?
    
    HTTP verbs are specified in the headers of a web request
    There are 4 different verbs that can be used: 'post', 'get', 'put', 'delete'

* Question: What does RESTful mean?

    REST stands for 'REpresentation State Transfer'
    An application is RESTful when it maps HTTP verbs to application endpoints (actions in Rails)
    Basically REST = HTTP verbs + CRUD

=== Respond_to Blocks
* Rails scaffolding provides html and xml by default

    # start your rails application and go to http://localhost:3000/posts
    # then visit http://localhost:3000/posts.xml
    # xml is built right in from the start

* You can change the format of the information your application returns
* html, xml, and json are built into Rails
* You can also specify your own custom types if necessary

  respond_to do |format|
    format.html # will render index.html.erb
    format.xml  { render :xml => @posts }
    format.json { render :json => @posts }
  end

* Please be aware the respond_to blocks are NOT REQUIRED
* You can remove them (keeping the required logic)
* Your application will still serve html requests by default

=== Views
* Views are where your markup and ERB live 
* You should try to keep complexity to a minimum
* No data logic or munging should happen here
* keep things dry by moving logic into helpers and repeated markup into helpers

=== ERB - embedded Ruby
* <%  %> and <%= %> are the tags for erb
* Execute Ruby within the context of html

    <% 1+1 %>       #=> will be evauluated but not displayed
    <%= 1+1 %>      #=> will be evaluated and displayed (2)
    <%# 1+1 %>      #=> will not be evaluated or displayed

=== Partials
* Extract common view logic into re-usable html fragments
* Partial filenames begin with an underscore: _post.html.erb

  <%= render :partial => 'post', :collection => @posts %>
  # will render the app/posts/_post.erb partial once for each post in @posts

* You can also pass local variables into the partial

  <%= render :partial => 'comment_fields', :locals => {:f => f } %>
  # will make the local form variable 'f' available in the partial
  
=== Lab 06: Extract Post Form Fields [ 06_extract_post_form_fields.rb ]
* Create a partial that will contain extracted post form fields
* Extract common form fields from app/views/posts/edit.html.erb and new.html.erb
* Put the common fields into the partial
* Make sure that the forms still function

=== Layouts
* Layouts are html/erb that wrap each of your views
* They live in /views/layouts
* It's common to have only a few layouts for your application
  - examples: application.html.erb, site.html.erb, admin.html.erb

* Scaffolds create a layout for each scaffold
  - you should ditch these and build your own application.html.erb

* This is also where you include your css and javascript files
* Include script.aculo.us and prototype

    <%= javascript_include_tag :defaults %>

* You can specify a layout manually in the controller

      class PostsController < ApplicationController
        layout 'custom_layout'
      end

* The default layout is 'app/views/layouts/application.html.erb'
* Yield is what will display each of your views
* This is where you can create your headers and footers

    <%= render :partial => 'header' %>
    <%= yield %>
    <%= render :partial => 'footer' %>

=== Helpers

* All helpers are available to your views

    # application_controller.rb
    helper :all
    # makes all helpers available to all views

* You can extract logic from your views into methods here
* These are normal ruby methods that you can access from your views

    # Example
    # app/helpers/posts_helper.rb
    module PostsHelper
      def comment_count(post)
        pluralize(post.comments.count, 'Comments')
      end
    end

    # in a view somewhere
    <%= comment_count(@post) %>

=== Routes
* This is where you specify what actions are available for your application

    rake routes
     - display all routes available to your application

    map.resources :posts
      - generate all routes for the posts_controller
        - localhost:3000/posts

    map.resources :posts, :has_many => :comments
      - generate all routes for the posts_controller along with routes for comments
        - localhost:3000/posts/:id/comments

    map.root => :controller_name, :action => :action_name
      - change the default route for your application to point at the specified location
      - make sure to delete public/index.html for the root route to be functional

=== Lab 07a: Nested Resources Part 1 [ 07a_nested_resources_part_1.rb ]
* Create a route that reflects the post has_many comments relationship
* Verify the routes using 'rake routes'

* Nest the CommentsController
  - Add a before filter to find the post from param[:post_id]
  - Hint: 

    private
      def find_post
        Post.find(params[:post_id]
      end

  - Only find and operate on comments scoped to the post found in the before filter
  - Hint:

    @comment = @post.comments.find(params[:id])

  - Change redirects to the PostsController#show action

=== Lab 07b: Nested Resources Part 2 [ 07b_nested_resources_part_2.rb ]
* List all comments associated with a post in app/views/posts/show.html.erb
* Add a comment form to app/views/posts/show.html.erb
  - You can steal the one from app/views/comments/new.html.erb
  - Make sure to update the form to use the proper nested route
  - Hint: 

    <% form_for :comment, :url => post_comments_path(@post) do |f| %>

=== Basic authentication
* This is BASIC authentication
* Good for quick one-offs
* Warning: username and password are sent to the server in PLAIN TEXT
    
    # in app/controllers/applicaiton_controller.rb

    private
      def authenticate
        authenticate_or_request_with_http_basic do |user, pass|
        user == "admin" && pass == "password"
      end

* You can protect methods by using before_filters in your controllers

    class PostsController < ApplicationController
      before_filter :authenticate, :only => [:destroy]

      def destroy
        # some logic
      end
    end
  
    # this will prompt a user for a username and a password on the destroy action

- For more robust authentication check out these plugins:
  - Authlogic: http://github.com/binarylogic/authlogic/tree/master
  - Clearance: http://github.com/thoughtbot/clearance/tree/master

=== Lab 08: Add basic authentication [ 08_add_basic_authentication.rb ]
* Protect the destroy and edit in the CommentsController with Basic Auth

=== Concepts

* DRY - Don't Repeat Yourself
  avoid duplicated code - extract duplicate code into a single method

* COC - Convention over Configuration
  - many of the small decisions have already been made for you
  - COC allows you to focus on the problem domain of your application instead of worrying about where code will live, how things will be named, etc

* MVC - Model, View, Controller
  - an architecture style that separates concerns of data/logic, action/request, and presentation

  View
    - User sees this level
    - html, markup, js, css, forms

  Models
    - business logic
    - database interaction
    - the bulk of your application logic
    - MAXIMUM FUNCTIONALITY

  Controller
    - brokers data between the Model and View
    - MINIMUM FUNCTIONALITY

* Fat Model, Skinny Controller
  - keep all of your logic in your model

=== Plugins and Gems
    you can add 3rd party functionaly to you application using plugins and gems

    Plugins
      ruby script/plugin install http://repo.pragprog.com/svn/Public/plugins/annotate_models
        - install annotate_models into vendor/plugins/annotate_models
      ruby script/plugin remove annotate_models
        - remove the installed plugin

    Gems
      sudo gem install mislav-will_paginate
        -installs the will_paginate gem onto your SYSTEM
      you can also specify which gems your application needs using config.gem
        - add the following line to your config/environment.rb

          config.gem 'mislav-will_paginate', :version => '~> 2.2.3', :lib => 'will_paginate', :source => 'http://gems.github.com'

        - sudo rake gems:install
          this will install all the gems required by the application to your SYSTEM

    Vendoring Rails
      you can freeze a rails version to your application
      once you've 'vendored', the app will use the vendor version of rails instead of the version installed on the system
      rake freeze:edge
        - will install the latest version of edgerails into your vendor folder
      rake freeze:edge VERSION=2.2.3
        - will freeze Rails 2.2.3 to the vendor folder

=== Testing
    this is a class in itself - we could fill volumes with testing methodology
    unfortunately we only went into this briefly

    The idea is that you want to write a test to assert your intention for the code you are about to write. You build up a set of regression test as you build your software.

    Red, Green, Refactor
      - write the test first, run it, it fails because there is no code (red)
      - write just enough code to satisfy the test, run it, it passes (green)
      - consider what you've just written and see if it could be written better in a different way (refactor)

    Autotest will run all of your tests automatically
      - it will sit and wait until you modify a file, then it will run the associated tests
      - sudo gem install ZenTest
      - just run 'autotest' in the root of your application

    Continous Integration Testing
      - watches your repository and will run the tests for each commit
      - will email the entire team if a test fails
      - check out Integrity http://integrityapp.com

    Test::Unit is the name of the built-in test suite that ships with Rails
      - Test::Unit (TDD)

    Rspec is the plugin/gem we used in class (Intridea Preferred)
      - http://rspec.info
      - Rspec (BDD) - Behavior Driven Development
      - spec/spec.opts - change --format from 'progress' to 'specdoc' for verbose output
      - I highly recommend you pick up the beta book on Rspec by the Pragmatic Programmers
        - http://pragprog.com/titles/achbd/the-rspec-book
        - written by the guys who created rspec and cucumber

    FactoryGirl is a fixtures replacement that we use at Intridea
      - you can build test fixtures on the fly instead of creating them beforehand
      - http://github.com/thoughtbot/factory_girl/tree/master

    Cucumber was only mentioned and is used for creating executable user stories
      - http://cukes.info

Resources

=== Intridea University Introduction to Ruby on Rails Mailing List
    - this is a private list for alumni of the Intro to rails course.
    - homepage:	http://groups.google.com/group/intridea-university-intro-to-rails
    - email: intridea-university-intro-to-rails@googlegroups.com

=== Why's Poignant Guide to Ruby
    - http://poignantguide.net/ruby
    - why the lucky stiff (_why) - @_why on twitter
    - all Ruby developers read this book when they start out
    - light hearted, in the spirit of the language
    - free pdf version
    - chunky bacon

=== Mr. Neighborly's Humble Little Ruby Book
    - http://www.humblelittlerubybook.com/
    - Jeremy McAnally of ENTP
    - light hearted, in the spirit of the language
    - free pdf version

=== Programming Ruby
    - http://www.pragprog.com/titles/ruby/programming-ruby
    - Dave Thomas and Andy Hunt of the Pragmatic Programmers
    - seems like it was the first Ruby book written in English
    - pretty good, odd examples, but a good reference

=== The Ruby Way
    - Hal Fulton
    - http://www.amazon.com/Ruby-Way-Second-Addison-Wesley-Professional/dp/0672328844
    - Hardcore language reference covering advanced topics

=== Ruby Cookbook
    - http://oreilly.com/catalog/9780596523695/
    - I've found this book to be quite valuable since ruby doesn't change often

=== Agile Web Development with Rails 3rd Edition
    - David Hansson and Dave Thomas
    - http://pragprog.com/titles/rails3/agile-web-development-with-rails-third-edition
    - The original Rails book, now in it's 3rd iteration

=== The RSpec Book
    - creators of RSpec and Cucumber
    - http://pragprog.com/titles/achbd/the-rspec-book


=== Railscasts
    - Ryan Bates
    - 150+ short screencasts on useful Rails topics

=== Peepcode
    - Geoffrey Grosenbach
    - Many 60+ min screencasts covering rails topics in-depth
    - $9 an episode (can get an unlimited license)

=== Confreaks
    - http://www2.confreaks.com/events
    - excellent videos of major Ruby conferences
    - GREAT stuff here -- can't recommend this highly enough

=== The Least Surprised in "The Red Scared"
    - http://www.youtube.com/watch?v=mXZ_htL1rOI
    - http://www.youtube.com/watch?v=ng95M-cRb44
    - http://www.youtube.com/watch?v=Du_RTMmofWM

